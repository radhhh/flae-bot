# Design Document: Serverless Discord Time-Tracking Assistant (FastAPI + Alembic + SQLAlchemy + Postgres)

## 1. Purpose

Build a Discord-based personal time tracking assistant that supports:

* Weekly time allocation per subject
* Single active focus session per user with clock-in / clock-out
* Pause / resume
* Optional session goal
* Clock-out correction: ability to adjust the effective time (especially when clock-out was late)
* Serverless deployment (no persistent websocket / gateway), using only Discord Interactions (slash commands, buttons, modals)
* Postgres as the source of truth

Non-goals (for now): TODOs, notes, knowledge base, multi-user teams, analytics dashboards.
---

## 2. User Experience Overview

### Core flow: session tracking

1. User: `/session in subject:search_engine goal:"finish web scraper"`

2. Bot responds with a message showing current status + buttons:

   * **Pause**
   * **Clock out**
   * **Edit purpose** (modal)

3. User pauses/resumes with buttons or sends `/session pause`, `/session resume`.

4. User clocks out with `/session out` or **Clock out** button.

5. Bot ends session provisionally and posts a summary message with:

   * measured duration
   * paused time
   * effective time
   * buttons:

     * **✅ Confirm**
     * **↩️ Reopen** 
     * **✏️ Adjust time** (modal)
     * **✏️ Edit purpose** (modal)

6. After adjust, the bot updates the stored override and refreshes the summary message. Confirm finalizes.

### Weekly allocation flow

1. User: `/alloc set subject:search_engine hours:6`

2. Bot creates a new subject or adjust an existing subject hours for the current week

3. Bot responds with the current time allocation for this week

4. User: * `/alloc show`

5. Bot responds with the current time allocation for this week

---

## 3. Interaction Design

### 3.1 Slash commands

* `/session in subject:<string> purpose:<string optional>`
* `/session out purpose:<string optional>`
* `/session pause`
* `/session resume`
* `/session status`
* `/alloc set subject:<string> hours:<number>`
* `/alloc show`

### 3.2 Buttons

Custom IDs should encode minimal state:

* include `action` + `session_id`
  Examples:
* `pause:<session_id>`
* `resume:<session_id>`
* `out:<session_id>`
* `confirm:<session_id>`
* `adjust_time:<session_id>`
* `edit_purpose:<session_id>`

On click:

* verify user owns the session
* verify session status compatible with the action
* execute transaction, update message

### 3.3 Modals

**Edit Purpose** modal:

* field: purpose text, initially filled with purpose from the clock in

**Adjust Effective Time** modal:

* field: “Effective duration” (accept `1h 20m`, `80m`, `1:20`, `4800s`)

Parsing rules (recommended):

* If contains “:” → interpret as H:MM
* Else parse tokens like `2h`, `15m`
* Else if plain number → assume minutes

---

## 4. Architecture

### 4.1 High-level

Serverless FastAPI HTTP-only bot using Discord Interactions.

Components:

* **Discord Interactions Endpoint** (Vercel Python function at /server/discord/router.py)

  * Verifies Discord signatures (Ed25519)
  * Handles slash commands, buttons, modals
  * Pass all interactions to Session Handler
  * Must respond quickly (use “defer” when necessary)

* **Main Endpoint** (Vercel Python function at /server/router.py)
  * Attach discord router.
  * Intentionally kept separate to allow other endpoints to be added

* **Session Handler** (Python functions at /app/session.py)
  * Control all time tracking functionality 

* **Dependencies** (FastAPI dependencies to handle request verification)
  * Verify discord signature and return user model

* **Postgres**
  * All durable state: subjects, allocations, sessions
  * Used for idempotency and concurrency control


No Discord Gateway/WebSocket. No background workers. Use controller-services-repository architecture.

### 4.2 Request lifecycles

**Discord interaction**

1. Discord POST → `/api/discord`
2. Verify signature
3. Route by interaction type:
   * Slash command
   * Button
   * Modal submit
4. Call appropriate function in session.py
5. Return response (immediate or deferred)

---

## 4. Data Model (Postgres)

### 4.1 Tables

#### `users`

Tracks user data
* `id` (text, PK, generated by discord)

#### `subjects`

Tracks per-user subjects (e.g., “COMP1130”, “Gym”, “Portal apps”).

* `id` (uuid or bigserial, PK)
* `user_id` (text, FK -> user)
* `name` (text)
* `created_at` (timestamptz)

Constraints:

* UNIQUE (`user_id`, `name`)

Indexes:

* (`user_id`, `name`)

---

#### `weekly_allocations`

Weekly planning targets.

* `id` (uuid/bigserial, PK)
* `user_id` (FK -> user.id)
* `subject_id` (FK → subjects.id)
* `week_start_date` (date) — Monday in user’s timezone (default Australia/Sydney)
* `minutes_allocated` (int)
* `created_at` (timestamptz)
* `updated_at` (timestamptz)

Constraints:

* UNIQUE (`user_id`, `subject_id`, `week_start_date`)
* CHECK (`minutes_allocated` >= 0)

Indexes:

* (`user_id`, `week_start_date`)
* (`subject_id`, `week_start_date`)

---

#### `sessions`

Single-user focus sessions with pause and effective-time override.

* `id` (uuid/bigserial, PK)
* `subject_id` (FK -> subjects.id)
* `user_id` (FK -> user.id)
* `started_at` (timestamptz)
* `ended_at` (timestamptz, nullable)
* `goal` (text, nullable)
* `note` (text, nullable)
* `status` (text) — `RUNNING`, `PAUSED`, `ENDED_UNCONFIRMED`, `ENDED_CONFIRMED`
* `total_paused_seconds` (int, default 0)
* `pause_started_at` (timestamptz, nullable)
* `effective_override_seconds` (int, nullable) — if set, becomes the “truth”
* `created_at` (timestamptz)
* `updated_at` (timestamptz)

Constraints:

* CHECK (`total_paused_seconds` >= 0)
* CHECK (`effective_override_seconds` IS NULL OR effective_override_seconds >= 0)

Indexes:

* (`user_id`, `status`)
* (`user_id`, `started_at` DESC)

Enforcing “at most one active session”:

* Implement in application logic with transactional locking (see §6), or
* (Optional) partial unique index if you keep statuses normalized:

  * UNIQUE (`user_id`) WHERE status IN ('RUNNING','PAUSED')

---

## 5. Core Logic

### 5.1 Effective time calculation

Let `now = ended_at if ended else current time`.

If `effective_override_seconds` is not null:

* `effective = effective_override_seconds`

Else:

* `base = now - started_at`
* `paused = total_paused_seconds + (now - pause_started_at if status == PAUSED else 0)`
* `effective = max(0, base - paused)`

### 5.2 Pause/resume

**Pause** (allowed only when RUNNING):

* set `status = PAUSED`
* set `pause_started_at = now`

**Resume** (allowed only when PAUSED):

* add to `total_paused_seconds += now - pause_started_at`
* set `pause_started_at = NULL`
* set `status = RUNNING`

### 5.3 Clock out

When user clocks out from RUNNING or PAUSED:

* If PAUSED, first accrue paused time up to now (same logic as resume but still ending)
* set `ended_at = now`
* set `status = ENDED_UNCONFIRMED`
* return summary message with adjustment options

#### 5.4 Adjust time

* **Modal** user enters desired effective duration (e.g., `1h 20m` / `80m` / `1:20`)

On adjust:

* compute new `effective_override_seconds`
* set it on session
* keep `status` as `ENDED_UNCONFIRMED` (until confirm)

### 5.5 Confirm

Set `status = ENDED_CONFIRMED`.

---